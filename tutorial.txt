git add filename 
git commit -a -m
git diff readme.txt 查看改动
git log --pretty=online  查看提交日志

git reset --hard HEAD^ 版本回退到上一个版本
HEAD is now at 2205b26 wrote a readme file

git reset --hard [版本号] 回退到指定版本

git reflog[查看git使用命令历史]
b920846 HEAD@{0}: reset: moving to b920
2205b26 HEAD@{1}: reset: moving to HEAD^
b920846 HEAD@{2}: commit: add GPL
2205b26 HEAD@{3}: commit (initial): wrote a readme file

1:git add  [将修改过的文件放到stage暂存区，以待提交]
2:git commit [只提交stage里的文件]
每次修改，如果不add到暂存区，那就不会加入到commit中

＃撤销修改
1:如果没有git add readme.txt放到暂存区，用git checkout -- readme.txt 撤销修改
2:如果git add readme.txt放到了暂存区，git reset HEAD readme.txt 把暂存区的修改撤销掉,再git checkout -- readme.txt撤销

[没有git add ,git checkout -- <file>]git checkout HEAD -- readme.txt
[如果已经git add放到暂存区，git reset HEAD <file>将修改从暂存区丢弃,再git checkout -- <file>撤销修改]

git checkout HEAD -- readme.txt
git reset HEAD <file> 只会撤销暂存区的本次修改，不会覆盖工作区的修改

#git rm 删除文件
git rm test.txt
git checkout -- test.txt 撤销删除

#远程仓库
git remote add origin git@github.com:NextZeus/learngit.git
git push -u origin master
由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。


#branch
Git鼓励大量使用分支：

查看分支：git branch

创建分支：git branch <name>

切换分支：git checkout <name>

创建+切换分支：git checkout -b <name>

合并某分支到当前分支：git merge <name>

删除分支：git branch -d <name>


用带参数的git log也可以看到分支的合并情况：
git log --graph --pretty=oneline --abbrev-commit 

#--no-off
git merge --no-ff -m "merge with no-ff" dev
合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并

#git stash
git stash apply 应用缓存区的修改
git stash drop 删除缓存区
git stash pop [上面两个的总命令]
git stash list
